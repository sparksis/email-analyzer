import React, { Component } from 'react';
import { generateStats } from '../../stores/messageStore.js'; // Ensure path is correct
import './SummaryTable.scss';

/**
 * @typedef {object} StatNodeKey
 * @property {string} key - The value of the current statistics key (e.g., an email address, a domain).
 * @property {number} count - The count associated with this key.
 */

/**
 * @typedef {import('collections/sorted-array-map').SortedArrayMap} SortedArrayMap
 * A SortedArrayMap where keys are strings or objects and values can be numbers or other SortedArrayMaps for nesting.
 * For this component, it's expected to be a tree-like structure generated by `generateStats`.
 * Each node in the map has `key` (StatNodeKey) and `value` (another SortedArrayMap or count).
 */

/**
 * `SummaryTree` is a React class component that displays a hierarchical summary
 * of email statistics. It fetches data using `generateStats` from `messageStore.js`
 * and recursively renders this data as a tree structure.
 * It can be filtered by a 'To' address via its `filter` prop.
 */
export default class SummaryTree extends Component {
    /**
     * Reference to an interval timer, currently not used but defined.
     * @type {number|null}
     */
    interval = null;

    /**
     * Initializes the component state.
     * @param {object} props - The component's props.
     * @param {string} [props.filter] - An optional 'To' address to filter the summary tree by.
     */
    constructor(props) {
        super(props);
        /**
         * Component state.
         * @type {{tree: SortedArrayMap|null}}
         */
        this.state = { tree: null };
    }

    /**
     * Lifecycle method called after the component mounts.
     * Initiates loading of the summary data.
     * Contains commented-out code for periodic reloading.
     */
    componentDidMount() {
        this.load();
        // setInterval(() => {
        //     this.load();
        // }, 200);
    }

    /**
     * Lifecycle method called before the component unmounts.
     * Clears any active interval timer.
     */
    componentWillUnmount() {
        if (this.interval) { // Check if interval is not null
            clearInterval(this.interval);
        }
    }

    /**
     * Asynchronously loads statistics data using `generateStats` and updates the component's state.
     * @async
     */
    async load() {
        try {
            const tree = await generateStats();
            this.setState({ tree });
        } catch (error) {
            console.error("SummaryTree: Failed to load stats", error);
            this.setState({ tree: null }); // Set tree to null or an error state
        }
    }

    /**
     * Recursively renders a node in the summary tree.
     * @param {Array<string>} types - An array of strings representing the hierarchy levels (e.g., ['To', 'Domain', 'From']).
     *                                The first element is the current level type being rendered.
     * @param {SortedArrayMap} node - The current statistics node (a SortedArrayMap) to render.
     * @returns {Array<JSX.Element>|undefined} An array of JSX elements representing the rendered child nodes,
     *                                         or undefined if filtered out.
     */
    renderNode(types, node) {
        const currentType = types[0];
        // `node.entries()` for SortedArrayMap might not be standard.
        // Assuming `node` is iterable and yields [StatNodeKey, SortedArrayMap|number] pairs.
        // If `node` is from `collections/sorted-array-map`, it should be `node.toArray().map(([key, value]) => ...)`
        // or iterate using `node.forEach((value, key) => ...)`.
        // For now, assuming `[...node.entries()]` works as intended by the original code.
        // The original code implies `key` is the StatNodeKey and `value` is the nested SortedArrayMap or count.
        // However, `collections/sorted-array-map` stores items as {key, value} where value is the actual data.
        // The `generateStats` and `toSortedMap` were adjusted to store StatNodeKey like objects as the *values*
        // in the SortedArrayMap. So, `entry.key` might be an internal map key, and `entry.value` is the StatNodeKey object.

        // Correcting iteration based on how toSortedMap stores data:
        // toSortedMap stores an array of {key: string, count: number, nested?: SortedArrayMap}
        // So, `node` itself is a SortedArrayMap where values are these objects.
        return node.map(item => { // `item` is the value object: {key, count, nested}
            const statKeyObject = item; // This is {key: 'email/domain', count: N, nested: SortedArrayMap}

            if (currentType === 'To' && this.props.filter && this.props.filter !== statKeyObject.key) return undefined;

            let keyElement;
            // Dynamically call render method based on type (e.g., renderTo, renderDomain)
            const renderMethodName = `render${currentType}`;
            if (this[renderMethodName]) {
                keyElement = this[renderMethodName](statKeyObject);
            } else {
                keyElement = this.renderUnknownKey(statKeyObject);
            }

            // If there's a nested map, recurse. Otherwise, this is a leaf or we don't go deeper.
            const children = statKeyObject.nested && types.length > 1
                ? this.renderNode(types.slice(1), statKeyObject.nested)
                : null;

            return <div key={statKeyObject.key} className={currentType}>{keyElement}{children}</div>;
        }).filter(Boolean); // Remove undefined entries from filtering
    }

    /**
     * Renders a generic key when no specific render method for its type is available.
     * @param {StatNodeKey} keyObj - The statistics key object.
     * @returns {JSX.Element} A span displaying the key and its count.
     */
    renderUnknownKey(keyObj) {
        return <span>{keyObj.key} ({keyObj.count})</span>;
    }

    /**
     * Renders a 'From' or 'Domain' key as a clickable link to search in Gmail.
     * @param {StatNodeKey} keyObj - The statistics key object (representing a 'From' address or 'Domain').
     * @returns {JSX.Element} A span containing a link with the key and its count.
     */
    renderFrom(keyObj) {
        // Assuming keyObj.key is the email or domain string
        const query = `from:${keyObj.key}`;
        const link = `https://mail.google.com/mail/u/#search/${encodeURIComponent(query)}`;
        return <span><a target='_blank' rel='noopener noreferrer' href={link}>{keyObj.key}</a> ({keyObj.count})</span>;
    }

    /** Alias for rendering domain keys, uses the same logic as rendering 'From' keys. */
    renderDomain = this.renderFrom;
    // TODO: Add renderTo if specific rendering for 'To' keys is needed.

    /**
     * Renders the SummaryTree component.
     * @returns {JSX.Element} The rendered SummaryTree.
     */
    render() {
        const types = ['To', 'Domain', 'From']; // Defines the hierarchy levels
        const view = this.state.tree ? this.renderNode(types, this.state.tree) : <p>Loading statistics...</p>;

        return <div className='SummaryTree'>{view}</div>;
    }
}
